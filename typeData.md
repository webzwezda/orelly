# Типы данных

## Что такое *undefined*

Тип undefined имеет тип данных undefined и логика проста. Это не объект, не число, не строка и не булевое значение... И вообще не определенное. Так почему бы не назначить этой не определенности не *определенный* тип?

> Undefined это то что еще не имеет значения или не было инициализированно

* Возвращается из функции если отсутствует конанда *return*
* Значение переменной которой еще не было присвоенно
* Значение элемента, не существующего в разрященнном массиве
* Значение не существующего свойства
* Значение удаленного свойства
* Значение которое не может быть заданно свойству при создании объекта

## Оператор *typeof* 

Оператор **typeof** встроен в JavaScript. Он используется для проверки типа операнда.

```javascript
var subject = 'Just a string';

var probe = typeof subject;
console.log(probe);
```

> Обратите внимание: для представления типов typeof использует строки вида 'string', 'boolean', 'number', 'object', 'undefined' и т.д



```javascript
var test1 = "abcdef";
var test2 = 123;
var test3 = true;
var test4 = {};
var test5 = [];
var test6;
var test7 = {"abcdef": 123};
var test8 = ["abcdef", 123];
function test9(){
    return "abcdef"
};
var test10 = null;
console.log(typeof test1);
console.log(typeof test2);
console.log(typeof test3);
console.log(typeof test4);
console.log(typeof test5);
console.log(typeof test6);
console.log(typeof test7);
console.log(typeof test8);
console.log(typeof test9);
console.log(typeof test10);

string
number
boolean
object
object
undefined
object
object
function
object
```

## Null

Разработчики хотели иметь одно значение для переменных, которые еще не были инициализированны, и другое для обозначения для отсутствия объекта.   

> *Null* чаще всего используется там, где **объект** еще не создан или не найден, а *Undefined* - для неинициализированных переменных, отсутствующих свойств или отсутствующих значений в массивах

## NaN

Nan - Not a Number

Для примера возьмум 0/0. Результат 0/0 не имеет собственного представления на компьютере, поэтому в Javascript он представляется специальным значением NaN.

> Это единственное значение в JavaScript которое не равное самому себе

Значение проверяется через специальную функцию `isNaN()`

``` javascript
NaN != NaN;

function sanitise(x) {
  if (isNaN(x)) {
    return NaN;
  }
  return x;
}

console.log(sanitise('1'));
// expected output: "1"

console.log(sanitise('NotANumber'));
// expected output: NaN
```

А сейчас дышите глубоко и ровно

``` javascript
var test = 0 / 0;
console.log(typeof test);
// Получим number
```

Считайте что NaN просто выбранно неудачно. Вероятно, вместо "не число" стоило использовать что то вроде "число, не имеющее представления". Лучше всего расматривать NaN как чило, которое не возможно представить по крайней мере на компьютере. 

## Оператор проверки равенства ==

Если сравнивать 99 == "99" то JavaScript произойдет преобразование строки в числу. Преобразование действует временно только на момент сравнения

### Сравнение булевого значения с любым другим типом

В этом случае булевое значение преобразуется в число и два числа сравниваются. True преобразуется в 1, а false в 0. 

``` javascript
1 == true
1 == 1
// Будет true
```

### Булевое значение сравнивается со строкой

На этот раз преобразований будет несколько и код выполнится. 

``` javascript
'1' == true
'1' == 1
1 == 1
// True
```

А если булевое значение будет записанно как литерал то его преобразование не произойдет

``` javascript
'true' == true
'true' == 1
NaN == 1
// false
```

## Сравнение Null и Undefined

Сравнение этих значений дает результат *true*

## Сравнение числа с пустой строкой

Пустая строка преобразуется в 0 и результатом будет false

``` javascript
1 ==""
1 == 0
false
```

## Сравнение 0 < true

Да и в этом случае true преобразуется в 1 и мы получим значение `true` ведь 0 меньше 1

## Конкатенация

Если к строке прибавить число или к числу прибавить строку то всегда будет конкатенация а не сложение 

``` javascript
var addi = 1 + '3'; // 13
var plus = '3' + 10; // 310
```

Другие арифметические операторы рассматриваются как арифметические операторы, а не не строковые операции. И все строки в выражении будут преобразованны в числа

``` javascript
var multi = '3' * 4; //12
var divi = 80 / '10'; // 8
var mini = '10' - 5; // 5
```

## Сравнение объектов

В первом случае мы просто сравниваем две ссылки. Не важно что хранится в оюъектах, если ссылки не одинаковы то и объекты не равны

``` javascript
if (var1 === var2 ){
    // да это же один объект
}
```

## Псевдоложные 

* undefined
* null
* 0
* Пустая строка
* NaN

